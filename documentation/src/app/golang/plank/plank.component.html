<h1>What is Plank?</h1>
<p>
    Plank is just enough of a platform to build whatever you want on top. It is a small yet powerful Golang server that can serve static contents,
    single page applications, create and expose microservices over REST endpoints or WebSocket via a built-in STOMP broker, or even interact directly
    with other message brokers such as RabbitMQ. All this is done in a consistent and easy to follow manner powered by Transport Event Bus.
</p>
<p>
    Writing a service for a Plank server is in a way similar to writing a Spring Boot Component or Service, because a lot of tedious plumbing work is
    already done for you such as creating an instance of a service and wiring it up with HTTP endpoints using routers etc.
    Just by following the API you can easily stand up a service, apply any kinds of middleware your application logic calls for,
    and do all these dynamically while in runtime, meaning you can conditionally apply a filter for certain REST endpoints, stand up a new service on demand,
    or even spawn yet another whole new instance of Plank at a different endpoint.
</p>
<p>
    All features are cleanly exposed as public API and modules and, combined with the power of Golang's concurrency model using channels,
    the Transport Event Bus allows creating a clean application architecture, with straightforward and easy to follow logic.
    Detailed tutorials and examples are currently in progress and will be made public on the Transport GitHub page.
    Some topics that will initially be covered are as follows:
</p>
<br/>
<ul>
    <li>Writing a simple service and interacting with it over REST and WebSocket</li>
    <li>Service lifecycle hooks</li>
    <li>Middleware management (for REST bridged services)</li>
    <li>Concept of local bus channel and galactic bus channel</li>
    <li>Communicating between Plank instances using the built-in STOMP broker</li>
    <li>Securing your REST and WebSocket endpoints using Auth Provider Manager</li>
</ul>
